## DataStore Strategy

Originally, the class implementing the data-source was going to be another member of the Datum variant.
But that design complicated the Object class, and introduced some overhead.  Since the data-source class
was defined in Object.h, it required some weirdness to insure that the data-source was notified of the
*Node* being read/written, even though it was the Object class that was invoking the data-source method.

After some consideration, the data-source interface will be defined in Node.h.  This bloats the Node class,
but, it's in keeping with the idea that the raw data is represented by instances of Object, and Node instances
are flyweights created and destroyed within an execution flow.  That isn't to say that the user won't maintain
containers of Nodes, but if the user really needs to store large numbers of objects, Object instances can always
be stored, instead of Node instances, at the cost of not having the parentage, and not being able to reload
an object from its data-source.

### Reference Counting DataStore

A DataStore instance is not tied to a specific Node instance.  For example, the same FileStore instance can be
used by all the file and folder objects in a directory tree, since all the information necessary to reconstruct
the absolute path of the file/folder is available at load time.

*It is the responsibility of the DataStore implementation to propigate the DataStore to newly loaded Nodes.*

### Container Key Access Performance

There are 3 or 4 sources of latency for a key lookup:

    1. The latency associated with a vector or hash-map access.
    2. A switch or conditional statement to determine the object type.
    3. A nullptr test for the presence of an IDataStore.
    4. Depending on the compiler and the optimization level, a temporary object may be created
       and an additional function invoked.  Hopefully, most compilers will elide this overhead.
       This design allows the compiler to collapse a key-read access followed by a key-write
       access (e.g. node["key"] = value).  This allows an IDataStore to avoid unnecessarily
       reading a large object into memory when the program only wants to make changes to the
       object in external storage.  (See ChangeLog, below).
       
### IDataStore ChangeLog

The DataStore architecture avoids unnecessarily loading an object into memory when the program
only wants to update the object in external storage.  External storage is only written when the
program requests it.  Therefore, if the program makes changes to an object that has not been 
loaded into memory, those changes must be stored in a change log.  If a change log exists and
the program performs a read access of the object, the change log is applied to the object 
immediately after the object is read from external storage, and the change log is discarded.
On the other hand, if the program discards the object without writing it to external storage,
then the overhead of loading a large object into memory is never incurred.
Additionally, in some cases the DataStore implementation may be able to update external storage
with less overhead.

